--- source.orig/configure	2009-01-06 20:49:36.000000000 -0500
+++ source/configure	2009-01-06 20:52:46.000000000 -0500
@@ -43617,7 +43617,7 @@
 
 
 
-for ac_header in linux/inotify.h asm/unistd.h
+for ac_header in sys/inotify.h asm/unistd.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
--- source.orig/configure.in	2009-01-06 20:49:36.000000000 -0500
+++ source/configure.in	2009-01-06 20:53:23.000000000 -0500
@@ -2540,7 +2540,7 @@
 fi
 
 AC_CACHE_CHECK([for inotify support],samba_cv_HAVE_INOTIFY,[
-AC_CHECK_HEADERS(linux/inotify.h asm/unistd.h)
+AC_CHECK_HEADERS(sys/inotify.h asm/unistd.h)
 AC_CHECK_FUNC(inotify_init)
 AC_HAVE_DECL(__NR_inotify_init, [#include <asm/unistd.h>])
 ],
--- source.orig/smbd/notify_inotify.c	2009-01-06 20:50:32.000000000 -0500
+++ source/smbd/notify_inotify.c	2009-01-06 20:52:24.000000000 -0500
@@ -30,7 +30,7 @@
 #include <asm/types.h>
 #endif
 
-#include <linux/inotify.h>
+#include <sys/inotify.h>
 #include <asm/unistd.h>
 
 #ifndef HAVE_INOTIFY_INIT
--- source/lib.orig/system.c	2009-04-28 21:03:26.000000000 -0400
+++ source/lib/system.c	2009-04-28 21:04:21.000000000 -0400
@@ -703,125 +703,16 @@
 }
 
 
-#if defined(HAVE_POSIX_CAPABILITIES)
-
-#ifdef HAVE_SYS_CAPABILITY_H
-
-#if defined(BROKEN_REDHAT_7_SYSTEM_HEADERS) && !defined(_I386_STATFS_H) && !defined(_PPC_STATFS_H)
-#define _I386_STATFS_H
-#define _PPC_STATFS_H
-#define BROKEN_REDHAT_7_STATFS_WORKAROUND
-#endif
-
-#include <sys/capability.h>
-
-#ifdef BROKEN_REDHAT_7_STATFS_WORKAROUND
-#undef _I386_STATFS_H
-#undef _PPC_STATFS_H
-#undef BROKEN_REDHAT_7_STATFS_WORKAROUND
-#endif
-
-#endif /* HAVE_SYS_CAPABILITY_H */
-
-/**************************************************************************
- Try and abstract process capabilities (for systems that have them).
-****************************************************************************/
-
-/* Set the POSIX capabilities needed for the given purpose into the effective
- * capability set of the current process. Make sure they are always removed
- * from the inheritable set, because there is no circumstance in which our
- * children should inherit our elevated privileges.
- */
-static BOOL set_process_capability(enum smbd_capability capability,
-				   BOOL	enable)
-{
-	cap_value_t cap_vals[2] = {0};
-	int num_cap_vals = 0;
-
-	cap_t cap;
-
-#if defined(HAVE_PRCTL) && defined(PR_GET_KEEPCAPS) && defined(PR_SET_KEEPCAPS)
-	/* On Linux, make sure that any capabilities we grab are sticky
-	 * across UID changes. We expect that this would allow us to keep both
-	 * the effective and permitted capability sets, but as of circa 2.6.16,
-	 * only the permitted set is kept. It is a bug (which we work around)
-	 * that the effective set is lost, but we still require the effective
-	 * set to be kept.
-	 */
-	if (!prctl(PR_GET_KEEPCAPS)) {
-		prctl(PR_SET_KEEPCAPS, 1);
-	}
-#endif
-
-	cap = cap_get_proc();
-	if (cap == NULL) {
-		DEBUG(0,("set_process_capability: cap_get_proc failed: %s\n",
-			strerror(errno)));
-		return False;
-	}
-
-	switch (capability) {
-		case KERNEL_OPLOCK_CAPABILITY:
-#ifdef CAP_NETWORK_MGT
-			/* IRIX has CAP_NETWORK_MGT for oplocks. */
-			cap_vals[num_cap_vals++] = CAP_NETWORK_MGT;
-#endif
-			break;
-		case DMAPI_ACCESS_CAPABILITY:
-#ifdef CAP_DEVICE_MGT
-			/* IRIX has CAP_DEVICE_MGT for DMAPI access. */
-			cap_vals[num_cap_vals++] = CAP_DEVICE_MGT;
-#elif CAP_MKNOD
-			/* Linux has CAP_MKNOD for DMAPI access. */
-			cap_vals[num_cap_vals++] = CAP_MKNOD;
-#endif
-			break;
-	}
-
-	SMB_ASSERT(num_cap_vals <= ARRAY_SIZE(cap_vals));
-
-	if (num_cap_vals == 0) {
-		cap_free(cap);
-		return True;
-	}
-
-	cap_set_flag(cap, CAP_EFFECTIVE, num_cap_vals, cap_vals,
-		enable ? CAP_SET : CAP_CLEAR);
-
-	/* We never want to pass capabilities down to our children, so make
-	 * sure they are not inherited.
-	 */
-	cap_set_flag(cap, CAP_INHERITABLE, num_cap_vals, cap_vals, CAP_CLEAR);
-
-	if (cap_set_proc(cap) == -1) {
-		DEBUG(0, ("set_process_capability: cap_set_proc failed: %s\n",
-			strerror(errno)));
-		cap_free(cap);
-		return False;
-	}
-
-	cap_free(cap);
-	return True;
-}
-
-#endif /* HAVE_POSIX_CAPABILITIES */
-
 /****************************************************************************
  Gain the oplock capability from the kernel if possible.
 ****************************************************************************/
 
 void set_effective_capability(enum smbd_capability capability)
 {
-#if defined(HAVE_POSIX_CAPABILITIES)
-	set_process_capability(capability, True);
-#endif /* HAVE_POSIX_CAPABILITIES */
 }
 
 void drop_effective_capability(enum smbd_capability capability)
 {
-#if defined(HAVE_POSIX_CAPABILITIES)
-	set_process_capability(capability, False);
-#endif /* HAVE_POSIX_CAPABILITIES */
 }
 
 /**************************************************************************
