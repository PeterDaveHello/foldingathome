--- cdrkit-1.1.7.1/genisoimage/boot-alpha.c	2006-12-30 10:46:49.000000000 -0500
+++ cdrkit-new/genisoimage/boot-alpha.c	2008-04-01 22:27:58.000000000 -0400
@@ -126,7 +126,9 @@
 
     write_le64(sum, (unsigned char *)&alpha_hppa_boot_sector[63]);
 
+#ifdef JIGDO_TEMPLATE           
     jtwrite(alpha_hppa_boot_sector, sizeof(alpha_hppa_boot_sector), 1, 0, FALSE);
+#endif
     xfwrite(alpha_hppa_boot_sector, sizeof(alpha_hppa_boot_sector), 1, outfile, 0, FALSE);
     last_extent_written++;
 
--- cdrkit-1.1.7.1/genisoimage/boot.c	2007-03-14 17:14:33.000000000 -0400
+++ cdrkit-new/genisoimage/boot.c	2008-04-01 22:36:06.000000000 -0400
@@ -374,7 +374,9 @@
 	 */
 	amt = roundup(last_extent_written, (CD_CYLSIZE/SECTOR_SIZE)) - last_extent_written;
 	for (n = 0; n < amt; n++) {
+#ifdef JIGDO_TEMPLATE
 		jtwrite(buffer, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 		xfwrite(buffer, SECTOR_SIZE, 1, outfile, 0, FALSE);
 		last_extent_written++;
 	}
@@ -405,7 +407,9 @@
 			memset(buffer, 0, sizeof (buffer));
 			if (read(f, buffer, SECTOR_SIZE) < 0)
 				comerr("Read error on '%s'.\n", boot_files[i]);
+#ifdef JIGDO_TEMPLATE           
 			jtwrite(buffer, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 			xfwrite(buffer, SECTOR_SIZE, 1, outfile, 0, FALSE);
 			last_extent_written++;
 		}
@@ -485,7 +489,9 @@
 		memcpy(buffer, &cd_label, 512);
 	}
 
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(buffer, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 	xfwrite(buffer, SECTOR_SIZE, 1, outfile, 0, FALSE);
 	last_extent_written++;
 	return (0);
@@ -523,7 +529,9 @@
 			comerr("Read error on '%s'.\n", genboot_image);
 
 		if (i != 0 || last_extent_written == session_start) {
+#ifdef JIGDO_TEMPLATE           
 			jtwrite(buffer, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 			xfwrite(buffer, SECTOR_SIZE, 1, outfile, 0, FALSE);
 			last_extent_written++;
 		}
--- cdrkit-1.1.7.1/genisoimage/boot-mips.c	2008-02-25 06:14:07.000000000 -0500
+++ cdrkit-new/genisoimage/boot-mips.c	2008-04-01 22:28:38.000000000 -0400
@@ -331,7 +331,9 @@
 	/* Create checksum */
 	vh_calc_checksum(&vh);
 
+#ifdef JIGDO_TEMPLATE           
     jtwrite(&vh, sizeof(vh), 1, 0, FALSE);
+#endif
     xfwrite(&vh, sizeof(vh), 1, outfile, 0, FALSE);
     last_extent_written++;
 
--- cdrkit-1.1.7.1/genisoimage/boot-mipsel.c	2006-11-26 17:01:59.000000000 -0500
+++ cdrkit-new/genisoimage/boot-mipsel.c	2008-04-01 22:29:14.000000000 -0400
@@ -249,7 +249,9 @@
     write_le32((extent * 4) + offset, (unsigned char *)&bb->bootmap[0].start);
     write_le32(count, (unsigned char *)&bb->bootmap[0].count);
     
+#ifdef JIGDO_TEMPLATE           
     jtwrite(sector, sizeof(sector), 1, 0, FALSE);
+#endif
     xfwrite(sector, sizeof(sector), 1, outfile, 0, FALSE);
     last_extent_written++;
 
--- cdrkit-1.1.7.1/genisoimage/CMakeLists.txt	2008-01-05 22:01:25.000000000 -0500
+++ cdrkit-new/genisoimage/CMakeLists.txt	2008-04-01 21:45:56.000000000 -0400
@@ -23,7 +23,7 @@
 ENDIF(USE_LIBICONV)
 ENDIF(HAVE_ICONV_H)
 
-ADD_DEFINITIONS(-DUSE_LARGEFILES -DABORT_DEEP_ISO_ONLY -DAPPLE_HYB -DUDF -DDVD_VIDEO -DSORTING -DHAVE_CONFIG_H -DUSE_LIBSCHILY -DUSE_SCG -DJIGDO_TEMPLATE)
+ADD_DEFINITIONS(-DUSE_LARGEFILES -DABORT_DEEP_ISO_ONLY -DSORTING -DHAVE_CONFIG_H -DUSE_LIBSCHILY -DUSE_SCG)
 
 SET(MKISOFS_MOST_SRCS apple.c boot.c desktop.c dvd_file.c dvd_reader.c eltorito.c exclude.c files.c fnmatch.c hash.c ifo_read.c joliet.c mac_label.c match.c multi.c name.c rock.c scsi.c stream.c tree.c udf.c vms.c volume.c write.c boot-alpha.c boot-hppa.c boot-mips.c md5.c jte.c rsync.c	boot-mipsel.c endian.c sha1.c checksum.c )
   
@@ -36,10 +36,10 @@
  
 
 #SET_SOURCE_FILES_PROPERTIES(${MKISOFS_MOST_SRCS} PROPERTIES )
-LINK_DIRECTORIES(../libhfs_iso ../librols ../libusal ../libunls  ../wodim)
+LINK_DIRECTORIES(../libhfs_iso ../librols ../libusal ../libunls  ../wodim ../../../glibc-32)
 
 ADD_EXECUTABLE (genisoimage genisoimage.c ${MKISOFS_MOST_SRCS})
-TARGET_LINK_LIBRARIES(genisoimage wodimstuff hfs_iso  ${MAGICLIBS} c unls z bz2 ${EXTRA_LIBICONV} ${EXTRA_LIBS})
+TARGET_LINK_LIBRARIES(genisoimage wodimstuff hfs_iso  ${MAGICLIBS} unls ${EXTRA_LIBICONV} ${EXTRA_LIBS} c c_nonshared)
 
 # common lib set and genisoimage source parts for the rest
 LINK_LIBRARIES(wodimstuff ${EXTRA_LIBS}  unls ${EXTRA_LIBICONV} )
--- cdrkit-1.1.7.1/genisoimage/eltorito.c	2008-02-26 02:59:05.000000000 -0500
+++ cdrkit-new/genisoimage/eltorito.c	2008-04-01 22:10:26.000000000 -0400
@@ -707,7 +707,9 @@
 	}
 	/* Next we write out the boot volume descriptor for the disc */
 	get_torito_desc(&gboot_desc);
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(&gboot_desc, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 	xfwrite(&gboot_desc, SECTOR_SIZE, 1, outfile, 0, FALSE);
 	last_extent_written++;
 	return (0);
--- cdrkit-1.1.7.1/genisoimage/genisoimage.c	2008-02-25 06:14:07.000000000 -0500
+++ cdrkit-new/genisoimage/genisoimage.c	2008-04-01 21:45:56.000000000 -0400
@@ -553,10 +553,12 @@
 	ONE_DASH},
 	{{"graft-points", no_argument, NULL, OPTION_USE_GRAFT},
 	'\0', NULL, "Allow to use graft points for filenames", ONE_DASH},
+#ifdef APPLE_HYB
 	{{"root", required_argument, NULL, OPTION_RELOC_ROOT},
 	'\0', "DIR", "Set root directory for all new files and directories", ONE_DASH},
 	{{"old-root", required_argument, NULL, OPTION_RELOC_OLD_ROOT},
 	'\0', "DIR", "Set root directory in previous session that is searched for files", ONE_DASH},
+#endif
 	{{"help", no_argument, NULL, OPTION_HELP},
 	'\0', NULL, "Print option help", ONE_DASH},
 	{{"hide", required_argument, NULL, OPTION_I_HIDE},
@@ -596,9 +598,10 @@
 	{{"max-iso9660-filenames", no_argument, NULL, OPTION_MAX_FILENAMES},
 	'\0', NULL, "Allow 37 character filenames for ISO9660 names (violates ISO9660)", ONE_DASH},
 
+#ifdef APPLE_HYB
 	{{"allow-limited-size", no_argument, NULL, OPTION_ALLOW_LIMITED_SIZE},
 	'\0', NULL, "Allow different file sizes in ISO9660/UDF on large files", ONE_DASH},
-
+#endif
 	{{"allow-leading-dots", no_argument, NULL, OPTION_ALLOW_LEADING_DOTS},
 	'\0', NULL, "Allow ISO9660 filenames to start with '.' (violates ISO9660)", ONE_DASH},
 	{{"ldots", no_argument, NULL, OPTION_ALLOW_LEADING_DOTS},
@@ -1714,12 +1717,14 @@
 		case 'M':
 			merge_image = optarg;
 			break;
+#ifdef APPLE_HYB
 		case OPTION_RELOC_ROOT:
 			reloc_root = optarg;
 			break;
 		case OPTION_RELOC_OLD_ROOT:
 			reloc_old_root = optarg;
 			break;
+#endif
 		case 'N':
 			omit_version_number++;
 			warn_violate++;
@@ -2409,11 +2414,11 @@
 			}
 			break;
 #endif	/* PREP_BOOT */
-#endif	/* APPLE_HYB */
 		case OPTION_ALLOW_LIMITED_SIZE:
 			allow_limited_size++;
       use_udf++;
 			break;
+#endif	/* APPLE_HYB */
 		default:
 			susage(1);
 		}
@@ -2430,13 +2435,16 @@
 	 * XXX This is a hack until we have a decent separate name handling
 	 * XXX for UDF filenames.
 	 */
+#ifdef DVD_VIDEO
 	if (dvd_video && use_Joliet) {
 		use_Joliet = 0;
 		fprintf(stderr, "Warning: Disabling Joliet support for DVD-Video.\n");
 	}
+#endif
+#ifdef UDF
 	if (use_udf && !use_Joliet)
 		jlen = 255;
-
+#endif
 	if (preparer) {
 		if (strlen(preparer) > 128) {
 			comerrno(EX_BAD, "Preparer string too long\n");
@@ -2510,7 +2518,11 @@
 #ifdef USE_ICONV
 	iconv_possible = !(iso9660_level >= 4 || ((ocharset &&
 		strcmp(ocharset, icharset ? icharset : "")) &&
-		use_RockRidge) || apple_ext || apple_hyb);
+		use_RockRidge)
+#ifdef APPLE_HYB
+                               || apple_ext || apple_hyb
+#endif
+                                                         );
 
 	setlocale(LC_CTYPE, "");
 	
@@ -2859,19 +2871,32 @@
 		save_pname = 1;
 	}
 	if (stream_media_size) {
-		if (use_XA || use_RockRidge || use_udf || use_Joliet)
+		if (use_XA || use_RockRidge
+#ifdef UDF
+                    || use_udf
+#endif 
+                    || use_Joliet)
 			comerrno(EX_BAD,
 			"Cannot use XA, Rock Ridge, UDF or Joliet with -stream-media-size\n");
 		if (merge_image)
 			comerrno(EX_BAD,
 			"Cannot use multi session with -stream-media-size\n");
 		if (use_eltorito || use_sparcboot || use_sunx86boot ||
-		    use_genboot || use_prep_boot || hfs_boot_file)
+		    use_genboot
+#ifdef PREP_BOOT
+                                || use_prep_boot
+#endif
+#ifdef APPLE_HYB
+                                || hfs_boot_file
+#endif
+                                )
 			comerrno(EX_BAD,
 			"Cannot use boot options with -stream-media-size\n");
+#ifdef APPLE_HYB
 		if (apple_hyb)
 			comerrno(EX_BAD,
 			"Cannot use Apple hybrid options with -stream-media-size\n");
+#endif
 	}
 
 	if (use_RockRidge) {
@@ -3385,6 +3410,7 @@
 			exit(1);
 #endif
 		}
+#ifdef JIGDO_TEMPLATE
 		if (jtemplate_out || jjigdo_out) {
 			if (!jtemplate_out || !jjigdo_out || !jmd5_list) {
 #ifdef USE_LIBSCHILY
@@ -3406,6 +3432,7 @@
 			}
 			write_jt_header(jttemplate, jtjigdo);
 		}
+#endif
 	} else {
 		discimage = stdout;
 
@@ -3670,14 +3697,14 @@
 		"Implementation botch: FS should end at %u but ends at %u.\n",
 				last_extent, last_extent_written);
 	}
-
+#ifdef JIGDO_TEMPLATE
 	if (jttemplate) {
 		write_jt_footer();
 		fclose(jttemplate);
 	}
 	if (jtjigdo)
 		fclose(jtjigdo);
-
+#endif
 	if (verbose > 0) {
 #ifdef HAVE_SBRK
 		fprintf(stderr, "Max brk space used %x\n",
--- cdrkit-1.1.7.1/genisoimage/joliet.c	2008-02-27 03:53:29.000000000 -0500
+++ cdrkit-new/genisoimage/joliet.c	2008-04-01 22:11:57.000000000 -0400
@@ -133,7 +133,7 @@
 #endif
 convert_to_unicode(unsigned char *buffer, int size, char *source, 
 						 struct unls_table *inls);
-static int	joliet_strlen(const char *string, struct nls_table *inls);
+static int	joliet_strlen(const char *string, struct unls_table *inls);
 #endif
 static void	get_joliet_vol_desc(struct iso_primary_descriptor *jvol_desc);
 static void	assign_joliet_directory_addresses(struct directory *node);
@@ -977,7 +977,9 @@
 			dir_index, dpnt->de_name);
 #endif
 	}
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(directory_buffer, total_size, 1, 0, FALSE);
+#endif
 	xfwrite(directory_buffer, total_size, 1, outfile, 0, FALSE);
 	last_extent_written += total_size >> 11;
 	free(directory_buffer);
@@ -1374,10 +1376,14 @@
 jpathtab_write(FILE *outfile)
 {
 	/* Next we write the path tables */
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(jpath_table_l, jpath_blocks << 11, 1, 0, FALSE);
+#endif
 	xfwrite(jpath_table_l, jpath_blocks << 11, 1, outfile, 0, FALSE);
 	last_extent_written += jpath_blocks;
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(jpath_table_m, jpath_blocks << 11, 1, 0, FALSE);
+#endif
 	xfwrite(jpath_table_m, jpath_blocks << 11, 1, outfile, 0, FALSE);
 	last_extent_written += jpath_blocks;
 	free(jpath_table_l);
@@ -1429,7 +1435,9 @@
 	/* Next we write out the boot volume descriptor for the disc */
 	jvol_desc = vol_desc;
 	get_joliet_vol_desc(&jvol_desc);
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(&jvol_desc, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 	xfwrite(&jvol_desc, SECTOR_SIZE, 1, outfile, 0, FALSE);
 	last_extent_written++;
 	return (0);
--- cdrkit-1.1.7.1/genisoimage/jte.c	2008-02-25 06:14:07.000000000 -0500
+++ cdrkit-new/genisoimage/jte.c	2008-04-01 21:56:47.000000000 -0400
@@ -9,6 +9,7 @@
  * GNU GPL v2
  */
 
+#ifdef JIGDO_TEMPLATE
 #include <mconfig.h>
 #include "genisoimage.h"
 #include <timedefs.h>
@@ -1046,3 +1047,4 @@
         add_unmatched_entry(pad_size);
     }        
 }
+#endif
--- cdrkit-1.1.7.1/genisoimage/mac_label.c	2006-12-08 08:38:43.000000000 -0500
+++ cdrkit-new/genisoimage/mac_label.c	2008-04-01 21:56:47.000000000 -0400
@@ -160,6 +160,7 @@
 
 #endif	/* PREP_BOOT */
 
+#ifdef APPLE_HYB
 int
 gen_mac_label(defer *mac_boot)
 {
@@ -423,3 +424,4 @@
 
 	return (0);
 }
+#endif
--- cdrkit-1.1.7.1/genisoimage/stream.c	2007-03-14 17:14:33.000000000 -0400
+++ cdrkit-new/genisoimage/stream.c	2008-04-01 22:27:17.000000000 -0400
@@ -161,7 +161,9 @@
 			break;
 		}
 		idx += count;
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(buf, count, 1, 0, FALSE);
+#endif
 		xfwrite(buf, count, 1, outfile, 0, FALSE);
 	}
 
@@ -170,7 +172,9 @@
 	memset(buf, 0, SECTOR_SIZE);
 	if (SECTOR_SIZE * iso_blocks - idx)
     {
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(buf, SECTOR_SIZE * iso_blocks - idx, 1, 0, FALSE);
+#endif
 		xfwrite(buf, SECTOR_SIZE * iso_blocks - idx, 1, outfile, 0, FALSE);
     }
 	/*
@@ -178,12 +182,16 @@
 	 */
 	for (count = 0; count < (avail_extent - iso_blocks); count++)
     {
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(buf, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 		xfwrite(buf, SECTOR_SIZE, 1, outfile, 0, FALSE);
     }
 	for (count = 0; count < stream_pad; count++)
     {
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(buf, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 		xfwrite(buf, SECTOR_SIZE, 1, outfile, 0, FALSE);
     }
 
@@ -213,10 +221,14 @@
 	set_723((char *)s_dir.volume_sequence_number, volume_sequence_number);
 	s_dir.name_len[0] = 1;
 	s_dir.name[0] = 0;	/* "." */
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(&s_dir, offsetof(struct iso_directory_record, name[0]) + 1, 1, 0, FALSE);
+#endif
 	xfwrite(&s_dir, offsetof(struct iso_directory_record, name[0]) + 1, 1, outfile, 0, FALSE);
 	s_dir.name[0] = 1;	/* ".." */
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(&s_dir, offsetof(struct iso_directory_record, name[0]) + 1, 1, 0, FALSE);
+#endif
 	xfwrite(&s_dir, offsetof(struct iso_directory_record, name[0]) + 1, 1, outfile, 0, FALSE);
 	memset(&s_dir, 0, sizeof (struct iso_directory_record));
 	s_dir.length[0] = 34 + strlen(stream_filename);
@@ -229,8 +241,10 @@
 	set_723((char *)s_dir.volume_sequence_number, volume_sequence_number);
 	s_dir.name_len[0] = strlen(stream_filename);
 	memcpy(s_dir.name, stream_filename, s_dir.name_len[0]);
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(&s_dir, offsetof(struct iso_directory_record, name[0])
 		+ s_dir.name_len[0], 1, 0, FALSE);
+#endif
 	xfwrite(&s_dir, offsetof(struct iso_directory_record, name[0])
 		+ s_dir.name_len[0], 1, outfile, 0, FALSE);
 
@@ -239,8 +253,10 @@
 	 * with filename length stream_filename + round up for even lenght count
 	 */
 	to_write = (s_dir.name_len[0] % 2) ? 0 : 1;
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(buf, SECTOR_SIZE - ((3 * 34) + s_dir.name_len[0]) +
 		to_write, 1, 0, FALSE);
+#endif
 	xfwrite(buf, SECTOR_SIZE - ((3 * 34) + s_dir.name_len[0]) +
 		to_write, 1, outfile, 0, FALSE);
 	free(buf);
@@ -254,10 +270,14 @@
 static int
 write_str_path(FILE *outfile)
 {
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(l_path, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 	xfwrite(l_path, SECTOR_SIZE, 1, outfile, 0, FALSE);
 	last_extent_written++;
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(m_path, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 	xfwrite(m_path, SECTOR_SIZE, 1, outfile, 0, FALSE);
 	last_extent_written++;
 	free(l_path);
--- cdrkit-1.1.7.1/genisoimage/write.c	2008-02-27 03:54:08.000000000 -0500
+++ cdrkit-new/genisoimage/write.c	2008-04-01 22:23:42.000000000 -0400
@@ -440,7 +440,11 @@
 
 	char *mirror_name;
 	unsigned char md5[16];
-	int include_in_jigdo = list_file_in_jigdo(filename, size, &mirror_name, md5);
+	int include_in_jigdo = 0;
+
+#ifdef JIGDO_TEMPLATE           
+	include_in_jigdo = list_file_in_jigdo(filename, size, &mirror_name, md5);
+#endif
 
 	if ((infile = fopen(filename, "rb")) == NULL) {
 #ifdef	USE_LIBSCHILY
@@ -461,8 +465,10 @@
 #endif	/* APPLE_HYB */
 	remain = size;
 
+#ifdef JIGDO_TEMPLATE
 	if (include_in_jigdo)
 		write_jt_match_record(filename, mirror_name, SECTOR_SIZE, size, md5);
+#endif
 
 	while (remain > 0) {
 		int	amt;
@@ -502,8 +508,10 @@
 #endif
 		}
 		if (!include_in_jigdo)
+#ifdef JIGDO_TEMPLATE           
 			jtwrite(buffer, use, 1,
 			        XA_SUBH_DATA, remain <= (SECTOR_SIZE * NSECT));
+#endif
 		xfwrite(buffer, use, 1, outfile,
 				XA_SUBH_DATA, remain <= (SECTOR_SIZE * NSECT));
 		last_extent_written += use / SECTOR_SIZE;
@@ -555,7 +563,9 @@
 				(Llong)dwpnt->size, dwpnt->extent);
 #endif
 		if (dwpnt->table) {
+#ifdef JIGDO_TEMPLATE           
 			jtwrite(dwpnt->table, ISO_ROUND_UP(dwpnt->size), 1, XA_SUBH_DATA, TRUE);
+#endif
 			xfwrite(dwpnt->table, ISO_ROUND_UP(dwpnt->size), 1,
 							outfile,
 							XA_SUBH_DATA, TRUE);
@@ -600,7 +610,9 @@
 			Uint	i;
 
 			for (i = 0; i < dwpnt->pad; i++) {
+#ifdef JIGDO_TEMPLATE           
 				jtwrite(blk, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 				xfwrite(blk, SECTOR_SIZE, 1, outfile, 0, FALSE);
 				last_extent_written++;
 			}
@@ -1526,7 +1538,9 @@
 			dir_index, dpnt->de_name);
 #endif
 	}
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(directory_buffer, total_size, 1, 0, FALSE);
+#endif
 	xfwrite(directory_buffer, total_size, 1, outfile, 0, FALSE);
 	last_extent_written += total_size >> 11;
 	free(directory_buffer);
@@ -1544,7 +1558,9 @@
 				ce_index, dpnt->ce_bytes);
 #endif
 		}
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(ce_buffer, ce_size, 1, 0, FALSE);
+#endif
 		xfwrite(ce_buffer, ce_size, 1, outfile, 0, FALSE);
 		last_extent_written += ce_size >> 11;
 		free(ce_buffer);
@@ -1771,7 +1787,9 @@
 		 * write out padding to round up to HFS allocation block
 		 */
 		for (i = 0; i < hfs_pad; i++) {
+#ifdef JIGDO_TEMPLATE           
 			jtwrite(buffer, sizeof (buffer), 1, 0, FALSE);
+#endif
 			xfwrite(buffer, sizeof (buffer), 1, outfile, 0, FALSE);
 			last_extent_written++;
 		}
@@ -1811,15 +1829,19 @@
 	/* write out extents/catalog/dt file */
 	if (apple_hyb) {
 
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(hce->hfs_ce, HFS_BLOCKSZ, hce->hfs_tot_size, 0, FALSE);
+#endif
 		xfwrite(hce->hfs_ce, HFS_BLOCKSZ, hce->hfs_tot_size, outfile, 0, FALSE);
 
 		/* round up to a whole CD block */
 		if (HFS_ROUND_UP(hce->hfs_tot_size) -
 					hce->hfs_tot_size * HFS_BLOCKSZ) {
+#ifdef JIGDO_TEMPLATE           
 			jtwrite(buffer,
 				HFS_ROUND_UP(hce->hfs_tot_size) -
 				hce->hfs_tot_size * HFS_BLOCKSZ, 1, 0, FALSE);
+#endif
 			xfwrite(buffer,
 				HFS_ROUND_UP(hce->hfs_tot_size) -
 				hce->hfs_tot_size * HFS_BLOCKSZ, 1, outfile, 0, FALSE);
@@ -1998,7 +2020,9 @@
 	}
 
 	/* if not a bootable cd do it the old way */
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(&vol_desc, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 	xfwrite(&vol_desc, SECTOR_SIZE, 1, outfile, 0, FALSE);
 	last_extent_written++;
 	return (0);
@@ -2015,7 +2039,9 @@
 	vol_desc.file_structure_version[0] = 2;
 
 	/* if not a bootable cd do it the old way */
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(&vol_desc, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 	xfwrite(&vol_desc, SECTOR_SIZE, 1, outfile, 0, FALSE);
 	last_extent_written++;
 	return (0);
@@ -2037,7 +2063,9 @@
 	evol_desc.type[0] = (unsigned char) ISO_VD_END;
 	memcpy(evol_desc.id, ISO_STANDARD_ID, sizeof (ISO_STANDARD_ID));
 	evol_desc.version[0] = 1;
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(&evol_desc, SECTOR_SIZE, 1, 0, TRUE);
+#endif
 	xfwrite(&evol_desc, SECTOR_SIZE, 1, outfile, 0, TRUE);
 	last_extent_written += 1;
 	return (0);
@@ -2092,10 +2120,14 @@
 	cp[SECTOR_SIZE - 1] = '\0';
  	/* Per default: keep privacy. Blackout the version and arguments. */
 	if(getenv("ISODEBUG")) {
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(vers, SECTOR_SIZE, 1, 0, TRUE);
+#endif
 		xfwrite(vers, SECTOR_SIZE, 1, outfile, 0, TRUE);
 	} else {
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(calloc(SECTOR_SIZE, 1), SECTOR_SIZE, 1, 0, TRUE);
+#endif
 		xfwrite(calloc(SECTOR_SIZE, 1), SECTOR_SIZE, 1, outfile, 0, TRUE);
 	}
     last_extent_written += 1;
@@ -2165,10 +2197,14 @@
 pathtab_write(FILE *outfile)
 {
 	/* Next we write the path tables */
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(path_table_l, path_blocks << 11, 1, 0, FALSE);
+#endif
 	xfwrite(path_table_l, path_blocks << 11, 1, outfile, 0, FALSE);
 	last_extent_written += path_blocks;
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(path_table_m, path_blocks << 11, 1, 0, FALSE);
+#endif
 	xfwrite(path_table_m, path_blocks << 11, 1, outfile, 0, FALSE);
 	last_extent_written += path_blocks;
 	free(path_table_l);
@@ -2181,7 +2217,9 @@
 static int
 exten_write(FILE *outfile)
 {
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(extension_record, SECTOR_SIZE, 1, 0, FALSE);
+#endif
 	xfwrite(extension_record, SECTOR_SIZE, 1, outfile, 0, FALSE);
 	last_extent_written++;
 	return (0);
@@ -2367,7 +2405,9 @@
 	npad = session_start + 16 - last_extent_written;
 
 	for (i = 0; i < npad; i++) {
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(buffer, sizeof (buffer), 1, 0, FALSE);
+#endif
 		xfwrite(buffer, sizeof (buffer), 1, outfile, 0, FALSE);
 		last_extent_written++;
 	}
@@ -2391,7 +2431,9 @@
 		npad += 16 - i;
 
 	for (i = 0; i < npad; i++) {
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(buffer, sizeof (buffer), 1, 0, FALSE);
+#endif
 		xfwrite(buffer, sizeof (buffer), 1, outfile, 0, FALSE);
 		last_extent_written++;
 	}
@@ -2408,7 +2450,9 @@
 	memset(buffer, 0, sizeof (buffer));
 
 	for (i = 0; i < 150; i++) {
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(buffer, sizeof (buffer), 1, 0, FALSE);
+#endif
 		xfwrite(buffer, sizeof (buffer), 1, outfile, 0, FALSE);
 		last_extent_written++;
 	}
@@ -2760,12 +2804,16 @@
 	r = tot_size % HFS_BLK_CONV;
 
 	/* write out HFS volume header info */
+#ifdef JIGDO_TEMPLATE           
 	jtwrite(hce->hfs_map, HFS_BLOCKSZ, tot_size, 0, FALSE);
+#endif
 	xfwrite(hce->hfs_map, HFS_BLOCKSZ, tot_size, outfile, 0, FALSE);
 
 	/* fill up to a complete CD block */
 	if (r) {
+#ifdef JIGDO_TEMPLATE           
 		jtwrite(buffer, HFS_BLOCKSZ, HFS_BLK_CONV - r, 0, FALSE);
+#endif
 		xfwrite(buffer, HFS_BLOCKSZ, HFS_BLK_CONV - r, outfile, 0, FALSE);
 		n++;
 	}
